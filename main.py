"""
Electric Vehicle Routing Problem Solver

This project implements Uniform Cost Search (UCS) and A* Search algorithms
to solve an Electric Vehicle (EV) routing problem in a synthetic city graph
with charging stations. The goal is to find the shortest path from node A to E
while respecting battery constraints.

Project Structure:
- graph/: Contains the city graph representation
- search/: Implements the search algorithms
- visualization/: Handles graph and performance visualizations
- utils/: Utility functions for performance tracking
- outputs/: Generated visualization files
- tests/: Unit tests for the algorithms

Author: Generated by GitHub Copilot
Date: November 5, 2025
"""

import sys
import os
import argparse
import random
from graph.city_graph import CityGraph
from search.algorithms import UniformCostSearch, AStarSearch
from visualization.show_graph import GraphVisualizer
from visualization.chartmaker import ChartMaker
from utils.performance import SearchResult

def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='Electric Vehicle Charging Station Finder')
    parser.add_argument('--battery', '-b', type=float,
                       help='Current battery capacity in km (random if not specified)')
    parser.add_argument('--start', '-s', type=str,
                       help='Starting node (random if not specified)')

    return parser.parse_args()

def main():
    """Main entry point for the EV charging station finder."""
    # Parse command-line arguments
    args = parse_arguments()

    # Set battery capacity - random if not specified
    if args.battery is not None:
        initial_battery = args.battery
        battery_source = "user-specified"
    else:
        initial_battery = round(random.uniform(2.0, 10.0), 1)
        battery_source = "random"

    # Initialize the city graph
    graph = CityGraph()

    # Set start node - random if not specified
    if args.start is not None:
        start_node = args.start.upper()
        start_source = "user-specified"
        # Validate that the start node exists
        if start_node not in graph.coords:
            print(f"Error: Start node '{start_node}' does not exist in the graph.")
            print(f"Available nodes: {', '.join(sorted(graph.coords.keys()))}")
            return
    else:
        start_node = random.choice(list(graph.coords.keys()))
        start_source = "random"

    print("Electric Vehicle Charging Station Finder")
    print("=" * 50)
    print(f"Start: {start_node} ({start_source}) - Battery: {initial_battery} km ({battery_source})")
    print(f"Goal: Find closest charging station")
    print(f"Charging stations: {', '.join(sorted(graph.charging_stations))}")
    print()

    # Run Uniform Cost Search
    print("Running Uniform Cost Search (UCS)...")
    ucs = UniformCostSearch(graph, start_node, initial_battery)
    ucs_result = ucs.search()

    # Run A* Search
    print("Running A* Search...")
    astar = AStarSearch(graph, start_node, initial_battery)
    astar_result = astar.search()

    # Print results
    print("\nResults:")
    print("-" * 50)
    print(f"UCS:  Path = {' → '.join(ucs_result.path)} | Cost = {ucs_result.cost:.1f} km | "
          f"Expanded = {ucs_result.nodes_expanded} | Time = {ucs_result.runtime:.4f}s")
    print(f"A*:   Path = {' → '.join(astar_result.path)} | Cost = {astar_result.cost:.1f} km | "
          f"Expanded = {astar_result.nodes_expanded} | Time = {astar_result.runtime:.4f}s")

    # Check if any valid paths were found
    has_valid_path = bool(ucs_result.path) or bool(astar_result.path)

    if not has_valid_path:
        print("\n❌ No EV Charging Stations are reachable with current battery capacity!")
        print("Consider increasing your battery range or finding a charging station nearby.")
        print("\nDone!")
        return

    # Generate visualizations only if paths were found
    print("\nGenerating visualizations...")

    # Create graph visualization - show both UCS and A* paths (only if they exist)
    visualizer = GraphVisualizer(graph)
    ucs_path = ucs_result.path if ucs_result.path else None
    astar_path = astar_result.path if astar_result.path else None
    visualizer.draw_graph(ucs_path, astar_path)

    # Create performance comparison chart
    chart_maker = ChartMaker()
    chart_maker.compare_performance(ucs_result, astar_result)

    print("Visualizations saved to outputs/ directory.")

    print("\nDone!")

if __name__ == "__main__":
    main()
